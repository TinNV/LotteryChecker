<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>D√≤ v√© s·ªë Nh·∫≠t B·∫£n</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
  <main class="app-shell">
    <section class="hero">
      <h1>D√≤ v√© s·ªë Nh·∫≠t B·∫£n</h1>
      <p>Nh·∫≠p nhi·ªÅu v√©, tra c·ª©u k·∫øt qu·∫£ nhanh ch√≥ng</p>
    </section>

    <form method="post" class="panel control-panel" id="checker-form">
      <div class="toolbar">
        <label>
          Lo·∫°i v√©
          <select name="game" id="game-select">
            {% for option in game_options %}
              <option value="{{ option.value }}" {% if selected_game == option.value %}selected{% endif %}>{{ option.label }}</option>
            {% endfor %}
          </select>
        </label>

        <label>
          K·ª≥ quay
          <input type="text" id="draw-number-input" name="draw_number" value="{{ draw_number_input }}" placeholder="ƒê·ªÉ tr·ªëng = k·ª≥ m·ªõi nh·∫•t">
        </label>

        <div class="action-row">
          <button type="button" id="add-ticket-btn" class="btn-secondary">Th√™m v√©</button>
          <button type="submit" class="btn-primary">D√≤ k·∫øt qu·∫£</button>
        </div>
      </div>

      <div class="scan-row">
        <input type="file" id="ticket-image-input" accept="image/*" hidden>
        <button type="button" id="scan-upload-btn" class="btn-ghost">ƒê·ªçc v√© t·ª´ ·∫£nh</button>
        <button type="button" id="scan-camera-btn" class="btn-ghost" hidden>Qu√©t b·∫±ng camera</button>
        <span id="scan-status" class="scan-status"></span>
      </div>

      <p id="rule-hint" class="hint"></p>

      <section id="number-ticket-section" class="ticket-section">
        <h3>Danh s√°ch v√© Loto</h3>
        <div id="number-ticket-list" class="ticket-list">
          {% for ticket in number_ticket_rows %}
            <div class="ticket-item">
              <span class="ticket-index">V√© {{ loop.index }}</span>
              <input type="text" name="tickets[]" value="{{ ticket }}" placeholder="V√≠ d·ª•: 1 6 11 26 33 40">
              <button type="button" class="btn-remove" aria-label="X√≥a v√©">X√≥a</button>
            </div>
          {% endfor %}
        </div>
      </section>

      <section id="traditional-ticket-section" class="ticket-section">
        <h3>Danh s√°ch v√© truy·ªÅn th·ªëng</h3>
        <div id="traditional-ticket-list" class="ticket-list">
          {% for row in traditional_ticket_rows %}
            <div class="ticket-item traditional">
              <span class="ticket-index">V√© {{ loop.index }}</span>
              <input type="text" name="ticket_groups[]" value="{{ row.group }}" placeholder="S·ªë t·ªï">
              <input type="text" name="ticket_numbers[]" value="{{ row.number }}" placeholder="S·ªë v√©">
              <button type="button" class="btn-remove" aria-label="X√≥a v√©">X√≥a</button>
            </div>
          {% endfor %}
        </div>
      </section>

      {% if recent_draw_numbers %}
        <div class="chips">
          <span>K·ª≥ g·∫ßn ƒë√¢y:</span>
          {% for draw_no in recent_draw_numbers %}
            <button
              type="submit"
              name="recent_draw_number"
              value="{{ draw_no }}"
              class="chip {% if draw_number_input and draw_number_input == (draw_no|string) %}active{% endif %}"
            >{{ draw_no }}</button>
          {% endfor %}
        </div>
      {% endif %}
    </form>

    <section class="panel history-panel">
      <div class="row">
        <h3>L·ªãch s·ª≠ d√≤ v√© g·∫ßn ƒë√¢y (local)</h3>
        <button type="button" class="btn-clear-history" id="clear-history-btn">X√≥a l·ªãch s·ª≠</button>
      </div>
      <div id="history-list" class="history-list"></div>
    </section>

    {% if error %}
      <section class="alert error"><strong>L·ªói:</strong> {{ error }}</section>
    {% endif %}

    {% if number_draw_result %}
      <section class="panel">
        <div class="row">
          <h2>{{ number_draw_result.draw_title }}</h2>
          <span class="meta">{{ number_draw_result.draw_date_jp }}</span>
        </div>
        <p class="meta">ƒê·ªãa ƒëi·ªÉm: {{ number_draw_result.venue }}</p>
        <div class="nums">
          <span class="label">S·ªë ch√≠nh:</span>
          {% for n in number_draw_result.main_numbers %}
            <span class="ball">{{ "%02d"|format(n) }}</span>
          {% endfor %}
        </div>
        <div class="nums">
          <span class="label">S·ªë bonus:</span>
          {% for n in number_draw_result.bonus_numbers %}
            <span class="ball bonus">{{ "%02d"|format(n) }}</span>
          {% endfor %}
        </div>
        <div class="meta-grid">
          <p>Carryover: {{ number_draw_result.carryover }}</p>
          <p>Doanh s·ªë: {{ number_draw_result.sales_amount }}</p>
          <p>Th·ªùi h·∫°n lƒ©nh th∆∞·ªüng: {{ number_draw_result.payment_period }}</p>
        </div>
      </section>

      <section class="panel">
        <div class="row">
          <h3>K·∫øt qu·∫£ d√≤ v√© Loto</h3>
          <span class="meta">V√© tr√∫ng: {{ number_win_count }}</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>V√© ƒë√£ nh·∫≠p</th>
              <th>Tr·∫°ng th√°i</th>
              <th>H·∫°ng</th>
              <th>Ti·ªÅn th∆∞·ªüng</th>
              <th>L·ªói</th>
            </tr>
          </thead>
          <tbody>
            {% for row in number_ticket_results %}
              <tr>
                <td>{{ row.index }}</td>
                <td>{{ row.raw }}</td>
                <td>{% if row.winning %}Tr√∫ng{% else %}Kh√¥ng tr√∫ng{% endif %}</td>
                <td>{{ row.rank }}</td>
                <td>{{ row.payout }}</td>
                <td>{{ row.error }}</td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </section>
    {% endif %}

    {% if traditional_draw_result %}
      <section class="panel">
        <div class="row">
          <h2>{{ traditional_draw_result.draw_title }}</h2>
          <span class="meta">{{ traditional_draw_result.draw_date_jp }}</span>
        </div>
        {% if traditional_draw_result.draw_subtitle %}
          <p class="meta">ƒê·ª£t ph√°t h√†nh: {{ traditional_draw_result.draw_subtitle }}</p>
        {% endif %}
        <p class="meta">ƒê·ªãa ƒëi·ªÉm: {{ traditional_draw_result.venue }}</p>
        <p class="meta">Th·ªùi h·∫°n lƒ©nh th∆∞·ªüng: {{ traditional_draw_result.payment_period }}</p>
      </section>

      <section class="panel">
        <div class="row">
          <h3>K·∫øt qu·∫£ d√≤ v√© truy·ªÅn th·ªëng</h3>
          <span class="meta">V√© tr√∫ng: {{ traditional_win_count }} | T·ªïng th∆∞·ªüng: {{ traditional_total_payout }}</span>
        </div>
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>T·ªï</th>
              <th>S·ªë v√©</th>
              <th>Tr·∫°ng th√°i</th>
              <th>T·ªïng ti·ªÅn</th>
              <th>Chi ti·∫øt gi·∫£i</th>
              <th>L·ªói</th>
            </tr>
          </thead>
          <tbody>
            {% for row in traditional_ticket_results %}
              <tr>
                <td>{{ row.index }}</td>
                <td>{{ row.group }}</td>
                <td>{{ row.number }}</td>
                <td>{% if row.winning %}Tr√∫ng{% else %}Kh√¥ng tr√∫ng{% endif %}</td>
                <td>{{ row.payout_display }}</td>
                <td>
                  {% if row.matches %}
                    {% for m in row.matches %}
                      <div>{{ m.rank }} - {{ m.amount }}</div>
                    {% endfor %}
                  {% endif %}
                </td>
                <td>{{ row.error }}</td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </section>

      <section class="panel">
        <h3>B·∫£ng k·∫øt qu·∫£ k·ª≥ quay</h3>
        <table>
          <thead>
            <tr>
              <th>H·∫°ng/Gi·∫£i</th>
              <th>Gi√° tr·ªã</th>
              <th>T·ªï</th>
              <th>S·ªë</th>
            </tr>
          </thead>
          <tbody>
            {% for row in traditional_draw_result.prize_rows %}
              <tr>
                <td>{{ row.rank }}</td>
                <td>{{ row.amount }}</td>
                <td>{{ row.group }}</td>
                <td>{{ row.number }}</td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </section>
    {% endif %}

    <footer class="footer">¬© TinNV4</footer>
  </main>

  <div id="camera-modal" class="camera-modal" aria-hidden="true">
    <div class="camera-backdrop"></div>
    <div class="camera-card">
      <div class="camera-head">
        <h3>Qu√©t v√© b·∫±ng camera</h3>
        <button type="button" id="camera-close-btn" class="icon-btn">√ó</button>
      </div>
      <div class="camera-stage">
        <video id="camera-video" autoplay playsinline></video>
        <div id="camera-frame" class="camera-frame">
          <span class="frame-tag">V√πng qu√©t</span>
          <span class="frame-note">CƒÉn d√≤ng c√≥ ‚ÄúÁ¨¨xxÂõû / xxÁµÑ / s·ªë v√© 6 ch·ªØ s·ªë‚Äù v√†o khung</span>
        </div>
      </div>
      <canvas id="camera-canvas" hidden></canvas>
      <div class="camera-actions">
        <button type="button" id="camera-capture-btn" class="btn-primary">Ch·ª•p v√† ƒë·ªçc</button>
      </div>
    </div>
  </div>

  {% if show_win_popup %}
    <div id="win-modal" class="win-modal show" role="dialog" aria-modal="true" aria-label="Th√¥ng b√°o tr√∫ng th∆∞·ªüng">
      <div class="win-backdrop"></div>
      <div class="win-card">
        <button type="button" id="close-win-modal" class="win-close" aria-label="ƒê√≥ng">√ó</button>
        <div class="win-headline">
          <div class="win-icon" aria-hidden="true">üèÜ</div>
          <div>
            <p class="win-kicker">Ch√∫c m·ª´ng</p>
            <h2>B·∫°n c√≥ v√© tr√∫ng th∆∞·ªüng</h2>
            <p class="win-sub">K·∫øt qu·∫£ n·ªïi b·∫≠t c·ªßa phi√™n d√≤ hi·ªán t·∫°i:</p>
          </div>
        </div>
        <ul class="win-list">
          {% for line in win_popup_lines %}
            <li>
              <span class="win-item-dot">‚úì</span>
              <span>{{ line }}</span>
            </li>
          {% endfor %}
        </ul>
        <button type="button" id="close-win-modal-cta" class="btn-primary win-cta">Tuy·ªát v·ªùi</button>
      </div>
    </div>
  {% endif %}

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    const HISTORY_KEY = "lottery_checker_history_v1";
    const HISTORY_LIMIT = 20;

    const numberSpecs = {{ number_specs | tojson }};
    const latestHistoryEntry = {{ history_entry | tojson }};

    const checkerForm = document.getElementById("checker-form");
    const gameSelect = document.getElementById("game-select");
    const drawNumberInput = document.getElementById("draw-number-input");
    const hint = document.getElementById("rule-hint");
    const numberSection = document.getElementById("number-ticket-section");
    const traditionalSection = document.getElementById("traditional-ticket-section");
    const numberList = document.getElementById("number-ticket-list");
    const traditionalList = document.getElementById("traditional-ticket-list");
    const addButton = document.getElementById("add-ticket-btn");

    const scanUploadButton = document.getElementById("scan-upload-btn");
    const scanCameraButton = document.getElementById("scan-camera-btn");
    const imageInput = document.getElementById("ticket-image-input");
    const scanStatus = document.getElementById("scan-status");

    const historyList = document.getElementById("history-list");
    const clearHistoryButton = document.getElementById("clear-history-btn");

    const cameraModal = document.getElementById("camera-modal");
    const cameraVideo = document.getElementById("camera-video");
    const cameraFrame = document.getElementById("camera-frame");
    const cameraCanvas = document.getElementById("camera-canvas");
    const cameraCloseButton = document.getElementById("camera-close-btn");
    const cameraCaptureButton = document.getElementById("camera-capture-btn");

    let currentCameraStream = null;

    function normalizeDigits(text) {
      const map = {
        "Ôºê": "0", "Ôºë": "1", "Ôºí": "2", "Ôºì": "3", "Ôºî": "4",
        "Ôºï": "5", "Ôºñ": "6", "Ôºó": "7", "Ôºò": "8", "Ôºô": "9",
      };
      return (text || "").replace(/[Ôºê-Ôºô]/g, (ch) => map[ch] || ch);
    }

    function normalizeOcrText(text) {
      let output = normalizeDigits(text);
      output = output.replace(/[|ÔΩú]/g, "1");
      output = output.replace(/(?<=\d)[Oo](?=\d)/g, "0");
      output = output.replace(/„Éº/g, "-");
      output = output.replace(/[‚Ä¢¬∑ÔΩ•]/g, " ");
      output = output.replace(/[^\S\r\n]+/g, " ");
      return output;
    }

    function uniqueStrings(values) {
      const seen = new Set();
      const out = [];
      values.forEach((item) => {
        if (!item || seen.has(item)) return;
        seen.add(item);
        out.push(item);
      });
      return out;
    }

    function extractDrawNumberFromText(text) {
      const normalized = normalizeOcrText(text);
      const patterns = [
        /Á¨¨\s*0*(\d{1,4})\s*Âõû/,
        /(?:Á¨¨)?\s*0*(\d{1,4})\s*Âõû/,
      ];
      for (const pattern of patterns) {
        const match = normalized.match(pattern);
        if (match) {
          return String(Number(match[1]));
        }
      }
      return "";
    }

    function cloneCanvas(canvas) {
      const cloned = document.createElement("canvas");
      cloned.width = canvas.width;
      cloned.height = canvas.height;
      const ctx = cloned.getContext("2d");
      ctx.drawImage(canvas, 0, 0);
      return cloned;
    }

    async function sourceToCanvas(source) {
      if (source instanceof HTMLCanvasElement) {
        return cloneCanvas(source);
      }

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      let imageBitmap = null;
      try {
        imageBitmap = await createImageBitmap(source);
        canvas.width = imageBitmap.width;
        canvas.height = imageBitmap.height;
        ctx.drawImage(imageBitmap, 0, 0);
        return canvas;
      } finally {
        if (imageBitmap && imageBitmap.close) {
          imageBitmap.close();
        }
      }
    }

    function cropCanvasByRatio(canvas, xRatio, yRatio, wRatio, hRatio) {
      const sx = Math.floor(canvas.width * xRatio);
      const sy = Math.floor(canvas.height * yRatio);
      const sw = Math.floor(canvas.width * wRatio);
      const sh = Math.floor(canvas.height * hRatio);

      const safeW = Math.max(1, Math.min(sw, canvas.width - sx));
      const safeH = Math.max(1, Math.min(sh, canvas.height - sy));

      const cropped = document.createElement("canvas");
      cropped.width = safeW;
      cropped.height = safeH;
      const ctx = cropped.getContext("2d");
      ctx.drawImage(canvas, sx, sy, safeW, safeH, 0, 0, safeW, safeH);
      return cropped;
    }

    function renumberRows(container) {
      container.querySelectorAll(".ticket-item").forEach((row, i) => {
        const label = row.querySelector(".ticket-index");
        if (label) label.textContent = `V√© ${i + 1}`;
      });
    }

    function createNumberRow(value = "") {
      const row = document.createElement("div");
      row.className = "ticket-item";
      row.innerHTML = `
        <span class="ticket-index"></span>
        <input type="text" name="tickets[]" placeholder="V√≠ d·ª•: 1 6 11 26 33 40">
        <button type="button" class="btn-remove" aria-label="X√≥a v√©">X√≥a</button>
      `;
      row.querySelector("input").value = value;
      return row;
    }

    function createTraditionalRow(group = "", number = "") {
      const row = document.createElement("div");
      row.className = "ticket-item traditional";
      row.innerHTML = `
        <span class="ticket-index"></span>
        <input type="text" name="ticket_groups[]" placeholder="S·ªë t·ªï">
        <input type="text" name="ticket_numbers[]" placeholder="S·ªë v√©">
        <button type="button" class="btn-remove" aria-label="X√≥a v√©">X√≥a</button>
      `;
      const inputs = row.querySelectorAll("input");
      inputs[0].value = group;
      inputs[1].value = number;
      return row;
    }

    function bindRemove(container) {
      container.addEventListener("click", (event) => {
        if (!event.target.classList.contains("btn-remove")) return;
        const rows = container.querySelectorAll(".ticket-item");
        if (rows.length <= 1) return;
        event.target.closest(".ticket-item").remove();
        renumberRows(container);
      });
    }

    function clearAndFillNumberTickets(tickets) {
      numberList.innerHTML = "";
      const values = tickets.length ? tickets : [""];
      values.forEach((ticket) => {
        numberList.appendChild(createNumberRow(ticket));
      });
      renumberRows(numberList);
    }

    function clearAndFillTraditionalTickets(tickets) {
      traditionalList.innerHTML = "";
      const values = tickets.length ? tickets : [{ group: "", number: "" }];
      values.forEach((ticket) => {
        traditionalList.appendChild(createTraditionalRow(ticket.group || "", ticket.number || ""));
      });
      renumberRows(traditionalList);
    }

    function setMode() {
      const selected = gameSelect.value;
      const spec = numberSpecs[selected];
      const isNumber = Boolean(spec);
      numberSection.style.display = isNumber ? "block" : "none";
      traditionalSection.style.display = isNumber ? "none" : "block";

      numberList.querySelectorAll("input").forEach((input) => { input.disabled = !isNumber; });
      traditionalList.querySelectorAll("input").forEach((input) => { input.disabled = isNumber; });

      if (isNumber) {
        hint.textContent = `M·ªói v√© nh·∫≠p ${spec.picks} s·ªë kh√¥ng tr√πng nhau trong kho·∫£ng ${spec.min_number}-${spec.max_number}.`;
      } else {
        hint.textContent = "M·ªói v√© nh·∫≠p theo c·∫∑p S·ªë t·ªï + S·ªë v√©.";
      }
    }

    function parseNumberTicketsFromText(text) {
      const spec = numberSpecs[gameSelect.value];
      if (!spec) return [];
      const normalized = normalizeOcrText(text)
        .replace(/Á¨¨\s*\d+\s*Âõû/g, " ")
        .replace(/\d+\s*[ÁµÑÁ≤óÂßê]/g, " ");
      const lines = normalized.split(/\r?\n/);
      const tickets = [];

      function lineToTickets(nums) {
        const out = [];
        if (nums.length < spec.picks) return out;

        if (nums.length === spec.picks && new Set(nums).size === spec.picks) {
          out.push(nums.join(" "));
          return out;
        }

        for (let start = 0; start + spec.picks <= nums.length; start += 1) {
          const chunk = nums.slice(start, start + spec.picks);
          if (new Set(chunk).size === spec.picks) {
            out.push(chunk.join(" "));
          }
        }
        return out;
      }

      for (const line of lines) {
        if (/Âπ¥|Êúà|Êó•/.test(line)) continue;
        const nums = (line.match(/\d+/g) || [])
          .map((n) => Number(n))
          .filter((n) => n >= spec.min_number && n <= spec.max_number);
        tickets.push(...lineToTickets(nums));
      }

      if (tickets.length) return uniqueStrings(tickets);

      const all = (normalized.match(/\d+/g) || [])
        .map((n) => Number(n))
        .filter((n) => n >= spec.min_number && n <= spec.max_number);

      for (let i = 0; i + spec.picks <= all.length; i += 1) {
        const chunk = all.slice(i, i + spec.picks);
        if (new Set(chunk).size === spec.picks) {
          tickets.push(chunk.join(" "));
        }
      }

      return uniqueStrings(tickets);
    }

    function parseTraditionalTicketsFromText(text) {
      const normalized = normalizeOcrText(text);
      const drawNo = extractDrawNumberFromText(normalized);
      const lines = normalized.split(/\r?\n/);
      const tickets = [];
      const groupHints = [];

      function addTicket(group, number) {
        if (!group || !number) return;
        if (drawNo && number === drawNo) return;
        if (number.length < 5 || number.length > 7) return;
        tickets.push({ group, number });
      }

      for (const line of lines) {
        const groupMatch = line.match(/(\d{1,3})\s*[ÁµÑÁ≤óÂßê]/);
        if (groupMatch) {
          groupHints.push(groupMatch[1]);
        }

        const pairRegex = /(\d{1,3})\s*[ÁµÑÁ≤óÂßê][^\d]*(\d{5,7})/g;
        for (const pair of line.matchAll(pairRegex)) {
          addTicket(pair[1], pair[2]);
        }

        if (!groupMatch) {
          const reversePairRegex = /(\d{5,7})[^\d]*(\d{1,3})\s*[ÁµÑÁ≤óÂßê]/g;
          for (const pair of line.matchAll(reversePairRegex)) {
            addTicket(pair[2], pair[1]);
          }
        }
      }

      if (!tickets.length) {
        const fallbackGroup = groupHints[0] || "";
        if (fallbackGroup) {
          const numbers = normalized.match(/\d{4,7}/g) || [];
          numbers
            .filter((item) => item !== fallbackGroup)
            .forEach((number) => addTicket(fallbackGroup, number));
        }
      }

      if (!tickets.length) {
        const loose = normalized.match(/\d+/g) || [];
        for (let i = 0; i + 1 < loose.length; i += 2) {
          const group = loose[i];
          const number = loose[i + 1];
          if (group.length <= 3 && number.length >= 5 && number.length <= 7) {
            addTicket(group, number);
          }
        }
      }

      const deduped = [];
      const seen = new Set();
      for (const item of tickets) {
        const key = `${item.group}-${item.number}`;
        if (seen.has(key)) continue;
        seen.add(key);
        deduped.push(item);
      }
      return deduped;
    }

    function enhanceCanvasForOcr(canvas, options = {}) {
      const { thresholdScale = 0.95, contrast = 1.0, brightness = 0 } = options;
      const output = cloneCanvas(canvas);
      const ctx = output.getContext("2d", { willReadFrequently: true });
      const imageData = ctx.getImageData(0, 0, output.width, output.height);
      const data = imageData.data;
      let sum = 0;

      for (let i = 0; i < data.length; i += 4) {
        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        sum += gray;
      }
      const avg = sum / (data.length / 4);
      const threshold = Math.max(85, Math.min(220, avg * thresholdScale));

      for (let i = 0; i < data.length; i += 4) {
        let gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        gray = (gray - 128) * contrast + 128 + brightness;
        const value = gray > threshold ? 255 : 0;
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      }
      ctx.putImageData(imageData, 0, 0);
      return output;
    }

    function buildOcrCandidates(baseCanvas) {
      const candidates = [];
      const centerCrop = cropCanvasByRatio(baseCanvas, 0.05, 0.2, 0.9, 0.6);

      candidates.push({
        label: "raw",
        canvas: baseCanvas,
        psm: "6",
      });
      candidates.push({
        label: "center-binary",
        canvas: enhanceCanvasForOcr(centerCrop, { thresholdScale: 0.94, contrast: 1.35 }),
        psm: "6",
      });
      candidates.push({
        label: "center-strong",
        canvas: enhanceCanvasForOcr(centerCrop, { thresholdScale: 0.9, contrast: 1.55 }),
        psm: "6",
      });
      candidates.push({
        label: "full-binary",
        canvas: enhanceCanvasForOcr(baseCanvas, { thresholdScale: 0.95, contrast: 1.25 }),
        psm: "11",
      });

      return candidates;
    }

    function scoreParsedResult(parsed, isNumberMode, normalizedText) {
      let score = 0;
      if (parsed.drawNo) score += 5;
      if (/Á¨¨\s*\d+\s*Âõû/.test(normalizedText)) score += 3;
      if (/\d+\s*[ÁµÑÁ≤óÂßê]/.test(normalizedText)) score += 3;

      if (isNumberMode) {
        score += parsed.numberTickets.length * 14;
        if (parsed.numberTickets.some((ticket) => ticket.split(/\s+/).length >= 6)) {
          score += 4;
        }
      } else {
        score += parsed.traditionalTickets.length * 14;
        if (parsed.traditionalTickets.some((ticket) => ticket.number.length === 6)) {
          score += 4;
        }
      }
      return score;
    }

    function parseOcrTextByMode(text, isNumberMode) {
      const normalizedText = normalizeOcrText(text);
      const drawNo = extractDrawNumberFromText(normalizedText);
      const numberTickets = parseNumberTicketsFromText(normalizedText);
      const traditionalTickets = parseTraditionalTicketsFromText(normalizedText);
      const score = scoreParsedResult(
        { drawNo, numberTickets, traditionalTickets },
        isNumberMode,
        normalizedText
      );

      return {
        text: normalizedText,
        drawNo,
        numberTickets,
        traditionalTickets,
        score,
      };
    }

    function applyParsedOcr(parsed) {
      if (parsed.drawNo) {
        drawNumberInput.value = parsed.drawNo;
      }

      const isNumberMode = Boolean(numberSpecs[gameSelect.value]);
      if (isNumberMode) {
        if (!parsed.numberTickets.length) {
          scanStatus.textContent = "Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c v√© h·ª£p l·ªá t·ª´ ·∫£nh.";
          return;
        }
        clearAndFillNumberTickets(parsed.numberTickets);
        setMode();
        scanStatus.textContent = `ƒê√£ nh·∫≠n di·ªán ${parsed.numberTickets.length} v√© Loto${parsed.drawNo ? ` ‚Ä¢ K·ª≥ ${parsed.drawNo}` : ""}.`;
        return;
      }

      if (!parsed.traditionalTickets.length) {
        scanStatus.textContent = "Kh√¥ng nh·∫≠n di·ªán ƒë∆∞·ª£c t·ªï/s·ªë v√© t·ª´ ·∫£nh.";
        return;
      }
      clearAndFillTraditionalTickets(parsed.traditionalTickets);
      setMode();
      scanStatus.textContent = `ƒê√£ nh·∫≠n di·ªán ${parsed.traditionalTickets.length} v√© truy·ªÅn th·ªëng${parsed.drawNo ? ` ‚Ä¢ K·ª≥ ${parsed.drawNo}` : ""}.`;
    }

    async function runOcr(source) {
      if (!window.Tesseract) {
        scanStatus.textContent = "Kh√¥ng t·∫£i ƒë∆∞·ª£c OCR engine.";
        return;
      }

      const isNumberMode = Boolean(numberSpecs[gameSelect.value]);
      scanStatus.textContent = "ƒêang x·ª≠ l√Ω ·∫£nh qu√©t...";

      try {
        const baseCanvas = await sourceToCanvas(source);
        const candidates = buildOcrCandidates(baseCanvas);
        let best = null;

        for (let i = 0; i < candidates.length; i += 1) {
          const candidate = candidates[i];
          scanStatus.textContent = `ƒêang OCR (${i + 1}/${candidates.length})...`;

          const result = await Tesseract.recognize(candidate.canvas, "eng+jpn", {
            tessedit_pageseg_mode: candidate.psm,
            preserve_interword_spaces: "1",
          });
          const parsed = parseOcrTextByMode(result.data.text || "", isNumberMode);
          if (!best || parsed.score > best.score) {
            best = { ...parsed, label: candidate.label };
          }

          const enoughConfidence = isNumberMode
            ? parsed.numberTickets.length >= 1 && (parsed.drawNo || parsed.score >= 16)
            : parsed.traditionalTickets.length >= 1 && (parsed.drawNo || parsed.score >= 16);
          if (enoughConfidence) {
            break;
          }
        }

        if (!best) {
          scanStatus.textContent = "OCR th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i ·∫£nh r√µ h∆°n.";
          return;
        }
        applyParsedOcr(best);
      } catch (error) {
        scanStatus.textContent = "OCR th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i ·∫£nh r√µ h∆°n.";
      }
    }

    function getHistory() {
      try {
        const raw = localStorage.getItem(HISTORY_KEY);
        return raw ? JSON.parse(raw) : [];
      } catch {
        return [];
      }
    }

    function saveHistoryEntry(entry) {
      if (!entry || !entry.game) return;
      const history = getHistory();
      const withMeta = {
        ...entry,
        saved_at: new Date().toISOString(),
      };
      const deduped = history.filter((item) => JSON.stringify(item.tickets) !== JSON.stringify(withMeta.tickets));
      deduped.unshift(withMeta);
      localStorage.setItem(HISTORY_KEY, JSON.stringify(deduped.slice(0, HISTORY_LIMIT)));
    }

    function formatTime(iso) {
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return "";
      return d.toLocaleString("vi-VN");
    }

    function applyHistoryEntry(entry) {
      gameSelect.value = entry.game || "traditional:zenkoku";
      drawNumberInput.value = entry.draw_number || "";

      if (entry.mode === "number") {
        clearAndFillNumberTickets((entry.tickets || []).map((item) => item.raw || ""));
        clearAndFillTraditionalTickets([{ group: "", number: "" }]);
      } else {
        clearAndFillTraditionalTickets(
          (entry.tickets || []).map((item) => ({ group: item.group || "", number: item.number || "" }))
        );
        clearAndFillNumberTickets([""]);
      }

      setMode();
      checkerForm.submit();
    }

    function renderHistory() {
      const history = getHistory();
      historyList.innerHTML = "";
      if (!history.length) {
        historyList.innerHTML = "<p class=\"history-empty\">Ch∆∞a c√≥ l·ªãch s·ª≠ d√≤ v√©.</p>";
        return;
      }
      history.forEach((entry, index) => {
        const item = document.createElement("div");
        item.className = "history-item";
        item.innerHTML = `
          <div class="history-main">
            <div class="history-title">${entry.game || "-"} | K·ª≥ ${entry.draw_number || "-"}</div>
            <div class="history-meta">${entry.summary || ""} ‚Ä¢ ${formatTime(entry.saved_at)}</div>
          </div>
          <button type="button" class="btn-history-view" data-index="${index}">Xem l·∫°i</button>
        `;
        historyList.appendChild(item);
      });

      historyList.querySelectorAll(".btn-history-view").forEach((button) => {
        button.addEventListener("click", () => {
          const index = Number(button.dataset.index);
          const history = getHistory();
          const entry = history[index];
          if (entry) applyHistoryEntry(entry);
        });
      });
    }

    addButton.addEventListener("click", () => {
      const isNumberMode = Boolean(numberSpecs[gameSelect.value]);
      if (isNumberMode) {
        numberList.appendChild(createNumberRow());
        renumberRows(numberList);
      } else {
        traditionalList.appendChild(createTraditionalRow());
        renumberRows(traditionalList);
      }
      setMode();
    });

    bindRemove(numberList);
    bindRemove(traditionalList);

    scanUploadButton.addEventListener("click", () => imageInput.click());
    imageInput.addEventListener("change", async () => {
      const file = imageInput.files && imageInput.files[0];
      if (!file) return;
      await runOcr(file);
      imageInput.value = "";
    });

    async function openCamera() {
      try {
        currentCameraStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1920 },
            height: { ideal: 1080 },
          },
        });
        cameraVideo.srcObject = currentCameraStream;
        cameraModal.classList.add("show");
        cameraModal.setAttribute("aria-hidden", "false");
        scanStatus.textContent = "ƒê∆∞a v√© v√†o khung, gi·ªØ m√°y ·ªïn ƒë·ªãnh r·ªìi b·∫•m Ch·ª•p v√† ƒë·ªçc.";
      } catch (error) {
        scanStatus.textContent = "Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c camera.";
      }
    }

    function closeCamera() {
      cameraModal.classList.remove("show");
      cameraModal.setAttribute("aria-hidden", "true");
      if (currentCameraStream) {
        currentCameraStream.getTracks().forEach((track) => track.stop());
        currentCameraStream = null;
      }
      cameraVideo.srcObject = null;
    }

    function captureCameraRoiToCanvas() {
      const videoWidth = cameraVideo.videoWidth;
      const videoHeight = cameraVideo.videoHeight;
      if (!videoWidth || !videoHeight) {
        return null;
      }

      const videoRect = cameraVideo.getBoundingClientRect();
      const frameRect = cameraFrame.getBoundingClientRect();

      const scaleX = videoWidth / videoRect.width;
      const scaleY = videoHeight / videoRect.height;

      let sx = Math.round((frameRect.left - videoRect.left) * scaleX);
      let sy = Math.round((frameRect.top - videoRect.top) * scaleY);
      let sw = Math.round(frameRect.width * scaleX);
      let sh = Math.round(frameRect.height * scaleY);

      if (!Number.isFinite(sx) || !Number.isFinite(sy) || !Number.isFinite(sw) || !Number.isFinite(sh)) {
        sx = 0;
        sy = 0;
        sw = videoWidth;
        sh = videoHeight;
      }

      sx = Math.max(0, Math.min(sx, videoWidth - 1));
      sy = Math.max(0, Math.min(sy, videoHeight - 1));
      sw = Math.max(1, Math.min(sw, videoWidth - sx));
      sh = Math.max(1, Math.min(sh, videoHeight - sy));

      const upscale = 2.0;
      const targetW = Math.max(1200, Math.floor(sw * upscale));
      const targetH = Math.max(500, Math.floor(sh * upscale));

      const ctx = cameraCanvas.getContext("2d");
      cameraCanvas.width = targetW;
      cameraCanvas.height = targetH;
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(cameraVideo, sx, sy, sw, sh, 0, 0, targetW, targetH);
      return cameraCanvas;
    }

    scanCameraButton.addEventListener("click", openCamera);
    cameraCloseButton.addEventListener("click", closeCamera);
    cameraModal.querySelector(".camera-backdrop").addEventListener("click", closeCamera);

    cameraCaptureButton.addEventListener("click", async () => {
      const roiCanvas = captureCameraRoiToCanvas();
      if (!roiCanvas) return;
      closeCamera();
      await runOcr(roiCanvas);
    });

    const clearHistory = () => {
      localStorage.removeItem(HISTORY_KEY);
      renderHistory();
    };
    clearHistoryButton.addEventListener("click", clearHistory);

    gameSelect.addEventListener("change", setMode);

    renumberRows(numberList);
    renumberRows(traditionalList);
    setMode();
    renderHistory();

    if (latestHistoryEntry) {
      saveHistoryEntry(latestHistoryEntry);
      renderHistory();
    }

    const modal = document.getElementById("win-modal");
    if (modal) {
      const closeButtons = [
        document.getElementById("close-win-modal"),
        document.getElementById("close-win-modal-cta"),
      ];
      closeButtons.forEach((btn) => {
        if (!btn) return;
        btn.addEventListener("click", () => modal.classList.remove("show"));
      });
      modal.querySelector(".win-backdrop").addEventListener("click", () => modal.classList.remove("show"));
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          modal.classList.remove("show");
        }
      });
    }
  </script>
</body>
</html>
